# App Flow Document

## Introduction

This application is designed as a backend REST API service that provides live data from worldometer’s "Live Counters" section. The main goal is to expose key world metrics, such as current population, births today, births this year, deaths today, deaths this year, and net population growth values. In addition to delivering these real-time numbers, the API calculates a change rate per minute by comparing the latest data with stored historical records in a Supabase database. The overall purpose is to allow developers to create real-time displays without the need to constantly poll the live website, while ensuring minimal load on the source through on-demand data fetching. The project is heavily focused on reliability with robust error handling and fallback strategies that indicate when data is not live.

## Onboarding and Sign-In/Sign-Up

Since this application is a REST API intended for developers, the onboarding process is more about accessing the API documentation and acquiring the endpoint information rather than a traditional user sign-up flow. Developers learn about the API via a dedicated documentation page or developer portal that outlines the API’s functionality, required parameters, and response structure. There is no standard sign-in mechanism for using the API because the service is built to be stateless and openly available for integration into real-time display applications. In scenarios where authentication might be implemented in the future, developers would register and obtain API credentials, but for the current version, direct access through the documented endpoint is sufficient.

## Main Dashboard or Home Page

The central access point for interacting with the API is the single REST endpoint that returns all the live counter metrics in a single JSON payload. Though the application does not host a comprehensive web dashboard for end-users, it does include a developer-facing documentation page that serves as the 'home page' for the API service. This documentation page provides details on how to make a request, what each metric represents, and how the change_per_minute is computed. It also outlines error flags that may appear in the response when fallback data is provided. Developers can easily navigate from this page to view code examples, integration tips, and troubleshooting guidelines, ensuring a seamless transition from learning about the API to making actual requests.

## Detailed Feature Flows and Page Transitions

When a developer sends a request to the API endpoint, the application immediately triggers the underlying Python API which utilizes a headless browser to load and interact with the worldometer website. At this stage, the API retrieves the live data from the "Live Counters" section, which includes various metrics like current population and key birth and death statistics. Once the live data is fetched, the API queries the Supabase database to obtain the most recent historical record for each metric, stored with a timestamp in UTC ISO8601 format. By comparing the latest value with the historical value and considering the time difference, the system computes the change_per_minute. The resulting data – a combination of current metrics and their corresponding change rates – is then assembled into a single JSON response payload. Should any step in this process fail, such as if the headless browser crashes or the worldometer website is unreachable, the API resorts to fallback data, logging the error details and including a flag in the response to alert the developer that the data might not be up-to-the-minute.

## Settings and Account Management

The current version of the system does not include personalized account management or a settings page for end-users since it operates as a stateless REST service for developers. However, a minimal configuration system is assumed to be in place for administrators and developers who manage the backend service. This configuration might include options for adjusting logging verbosity, setting thresholds for error alerts, or modifying the frequency of historical data updates within the Supabase database. Any changes made via these administrative controls would immediately reflect in the processing logic, but developers consuming the API continue to interact solely with the public endpoint. After any configuration updates or troubleshooting activities, the system naturally returns to its default operational flow without interrupting ongoing API requests.

## Error States and Alternate Paths

The API is built with comprehensive error handling mechanisms to ensure a smooth user experience even when issues occur. When the Python API encounters an error – such as problems with the headless browser, network failures, or issues within the worldometer site – the REST API immediately switches to a fallback mode. In fallback mode, the API retrieves previously stored data, computes the change rate using the latest available historical values, and includes a specific flag in the response to indicate that the data is not live but fallback data. All errors and exceptions are captured using Python’s logging module, giving developers detailed insight into what went wrong and providing cues for potential recovery. This robust error handling ensures that even if the live data cannot be fetched, developers always receive a meaningful response that continues to support real-time display requirements.

## Conclusion and Overall App Journey

From the initial exposure via a documentation page and straightforward onboarding process to the moment a developer sends a request, the entire app flow is designed to be clear and efficient. Developers access a single, well-documented REST endpoint that drives the live data fetching from worldometer through a Python API running a headless browser. The service then enriches this live data by comparing current values with historical data stored in a Supabase database to calculate change_per_minute. Any issues encountered during the process automatically activate fallback mechanisms, ensuring that meaningful data is still served and clearly flagged as such. In the end, the API journey from request initiation to response delivery is seamless and straightforward, providing developers with reliable real-time metrics essential for dynamic and responsive displays.
